<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Intelligent Agents</a></li><li><ol class="section"><li class="expanded "><a href="chapter_2_table.html"><strong aria-hidden="true">2.1.</strong> Table Driven</a></li><li class="expanded "><a href="chapter_2_reflex.html"><strong aria-hidden="true">2.2.</strong> Simple Reflexes</a></li><li class="expanded "><a href="chapter_2_fallible.html"><strong aria-hidden="true">2.3.</strong> Fallibility</a></li><li class="expanded "><a href="chapter_2_model.html"><strong aria-hidden="true">2.4.</strong> Model Based</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is a Rust implementation of programs in <a href="http://aima.cs.berkeley.edu/"><strong>Artifical Intelligence: A Modern Approach</strong></a>.
For more complete examples please see the <a href="http://j">Java</a> and <a href="http://p">Python</a> repositories.
Rust is a systems programming language that aims to be <a href="https://www.rust-lang.org/">fast, reliable, and productive</a>,
and is already being used in major initiatives like HuggingFace's
<a href="https://github.com/huggingface/tokenizers">state of the art NLP tokenizers</a> and Argo AI's 
<a href="https://argo.ai">autonomous driving platform</a>. It has many features that make it an attractive choice for developing AI
systems. One example is the basic safety guarantees provided:</p>
<ol>
<li>
<p>Programs that compile in standard Rust are guaranteed to be free of memory corruption. If you weren't aware,
memory-corruption results in <strong>undefined program behaviour</strong>.</p>
</li>
<li>
<p>Concurrent mutable access <em>does not even compile</em>. This in most cases eliminates concerns of &quot;data races&quot;.
Furthermore, higher-level abstractions in the language make it possible to develop similar ad-hoc safety guarantees for
your own programs.</p>
</li>
</ol>
<p>If you are not already familiar with Rust, this may not be the best starting point. There is an
<a href="https://docs.rust-lang.org">excellent introductory book here that you can get started with</a> and
use alongside this repository. The documentation is gentle in the introductory sections but
quickly builds up to assume that you have at minimum beginner knowledge of programming in Rust.</p>
<p><em>Instructions on how to use this as a companion to studying the book goes here</em></p>
<h1><a class="header" href="#table-driven-agent" id="table-driven-agent">Table Driven Agent</a></h1>
<blockquote>
<p><strong>function</strong> TABLE-DRIVEN-AGENT(<em>percept</em>) <strong>returns</strong> an action<br />
 <strong>persistent</strong>: <em>percepts</em>, a sequence, initially empty<br />
      <em>table</em>, a fully specified table of actions, indexed by percept sequences, <br/></p>
<p> append <em>percept</em> to the end of <em>percepts</em><br />
 <em>action</em> ← LOOKUP(<em>percepts</em>, <em>table</em>)<br />
 <strong>return</strong> <em>action</em></p>
<hr />
<p><strong>Figure 2.3</strong> The TABLE-DRIVEN-AGENT program is invoked for each new percept and returns an action each time. It retains the complete percept sequence in memory.</p>
</blockquote>
<p>The table driven agent program is fairly simple to implement. We need a function that
on each percept, stores the percept, and then resolves an action using a lookup table of
the complete percept history.</p>
<p>We can use a simple Hash Map to represent the table:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(trait_alias)]
</span><span class="boring">use std::collections::HashMap;
</span>trait Lookup = Eq + std::hash::Hash;

type Table&lt;Percept: Lookup, Action&gt; = HashMap&lt;Vec&lt;Percept&gt;, Action&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>This data structure may look a little intimidating if you are just getting started with
Rust. We've defined a short-hand for <code>std::collections::HashMap</code> called <code>Table</code> that is generic
over the <code>Percepts</code> received and <code>Actions</code> produced. The trait <code>Lookup</code> is defined to satisfy
some requirements of the HashMap structure, specifically, that Percepts can be <em>hashed</em> and
they can be <em>compared for equivalence</em>.</p>
<p>Now, we'll create some boilerplate to instantiate and run new programs. We'll use a struct
to store the percept history and table of sequence to actions.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::table::{Lookup, Table};
</span>struct TableDrivenAgent&lt;Percept: Lookup, Action&gt;{
    percepts: Vec&lt;Percept&gt;,
    table: Table&lt;Percept, Action&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, let's implement our program.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::table::{Lookup, Table};
</span><span class="boring">struct TableDrivenAgent&lt;Percept: Lookup, Action&gt;{
</span><span class="boring">   percepts: Vec&lt;Percept&gt;,
</span><span class="boring">   table: Table&lt;Percept, Action&gt;
</span><span class="boring">}
</span>impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
    // Run is called for each percept received from the environment
    fn run(&amp;mut self, percept: Percept) -&gt; &amp;Action {
        // Push the percept into our history sequence
        self.percepts.push(percept);
        // Lookup an action for the history sequence and return it
        self.table.get(&amp;self.percepts).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Great. We've created a table driven agent program. One last thing we forgot to do, we need
to be able to create the program given a table!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::table::{Table, Lookup};
</span><span class="boring">struct TableDrivenAgent&lt;Percept: Lookup, Action&gt;{
</span><span class="boring">    percepts: Vec&lt;Percept&gt;,
</span><span class="boring">    table: Table&lt;Percept, Action&gt;
</span><span class="boring">}
</span>impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
  fn new(table: Table&lt;Percept, Action&gt;) -&gt; Self {
      TableDrivenAgent {
          table, percepts: Vec::new()
      }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will give us a short-hand initialization for programs that looks like</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let agent = TableDrivenAgent::new(table);
<span class="boring">}
</span></code></pre></pre>
<p>Let's put our newly defined table driven agent code into practice: imagine that far off in the
future windows to our houses are intended to open and close automatically based on the outside
conditions. For example, we may open the windows in the Summer to let in fresh air on a sunny day.
When it rains, we shut the windows to keep the house dry.</p>
<p>To keep things simple let's say our agent should open the window when it is sunny and
close the window when it is rainy.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The agent's percepts
#[derive(PartialEq, Eq, Hash, Clone)]
enum Weather {
    Sunny, Rainy
}
// The agent's actions
enum Window {
    Open, Close
}
<span class="boring">}
</span></code></pre></pre>
<p>We'll create a simple table to deal with the changing outside conditions. First, let's
set-up the initial conditions.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::table::Table;
</span><span class="boring">use aima_rust::agents::envs::weather::{Weather, Window};
</span>let mut table = Table::new();
table.insert(vec![Weather::Sunny], Window::Open);
table.insert(vec![Weather::Rainy], Window::Close);
<span class="boring">}
</span></code></pre></pre>
<p>When our agent boots up, it should be able to perceive the weather and act rationally. We'll
be optimistic and test the agent out with a sensor reading of a warm breezy atmosphere.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::table::{TableDrivenAgent, Table};
</span><span class="boring">use aima_rust::agents::envs::weather::{Weather, Window};
</span><span class="boring">let mut table = Table::new();
</span><span class="boring">table.insert(vec![Weather::Sunny], Window::Open);
</span><span class="boring">table.insert(vec![Weather::Rainy], Window::Close);
</span>let mut agent = TableDrivenAgent::new(table);

let action = agent.run(Weather::Sunny);
assert_eq!(*action, Window::Open)
<span class="boring">}
</span></code></pre></pre>
<p>Ok great, the window is doing exactly what it should be doing. Now let's make it work for more than
one time step. Our table agent should be able to react to all percept sequences. One way to create this table
is to look at the longest sequences in the table and consider what can happen next: sun or rain, and 
then add that percept sequence into the table.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(trait_alias)]
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">trait Lookup = Eq + std::hash::Hash;
</span><span class="boring">
</span><span class="boring">type Table&lt;Percept: Lookup, Action&gt; = HashMap&lt;Vec&lt;Percept&gt;, Action&gt;;
</span><span class="boring">struct TableDrivenAgent&lt;Percept: Lookup, Action&gt;{
</span><span class="boring">    percepts: Vec&lt;Percept&gt;,
</span><span class="boring">    table: Table&lt;Percept, Action&gt;
</span><span class="boring">}
</span><span class="boring">impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
</span><span class="boring">    // Run is called for each percept received from the environment
</span><span class="boring">    fn run(&amp;mut self, percept: Percept) -&gt; &amp;Action {
</span><span class="boring">        // Push the percept into our history sequence
</span><span class="boring">        self.percepts.push(percept);
</span><span class="boring">        // Lookup an action for the history sequence and return it
</span><span class="boring">        self.table.get(&amp;self.percepts).unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
</span><span class="boring">  fn new(table: Table&lt;Percept, Action&gt;) -&gt; Self {
</span><span class="boring">      TableDrivenAgent {
</span><span class="boring">          table, percepts: Vec::new()
</span><span class="boring">      }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">// The agent's percepts
</span><span class="boring">#[derive(PartialEq, Eq, Hash, Clone)]
</span><span class="boring">enum Weather {
</span><span class="boring">    Sunny, Rainy
</span><span class="boring">}
</span><span class="boring">// The agent's actions
</span><span class="boring">enum Window {
</span><span class="boring">    Open, Close
</span><span class="boring">}
</span><span class="boring">let mut table = Table::new();
</span>loop {
    // Find the longest sequences in the table
    let max_length = table.keys()
        .map(|ks| ks.len())
        .max().unwrap_or(0);
    
    // &amp; all sequences of that length 
    let sequences_to_extend: Vec&lt;Vec&lt;Weather&gt;&gt; = table.keys()
        .filter(|k| k.len() == max_length)
        .cloned()
        .collect()

    // Extend them with the next percept permutations
    // and add back into the table
    sequences_to_extend.iter().for_each(|percepts| {
      let mut rainy_path = percepts.clone();
      rainy_path.push(Weather::Rainy);
      table.insert(rainy_path, Window::Close);

      let mut sunny_path = percepts.clone();
      sunny_path.push(Weather::Sunny);
      table.insert(sunny_path, Window::Open);
   });
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have been complicit to this point, running the preceding block in the playground should
have resulted in a <code>KILL TIMEOUT</code> error, and locally you would have surely exceeded the memory
limits of your computer! Our loop, while conceptually correct in creating the agent table for
any weather that could happen, is an irrational agent implementation. Recall from the book:</p>
<blockquote>
<p>It is instructive to consider why the table-driven approach to agent construction is doomed
to failure. Let \(P\) be the set of possible percepts and let \(T\) be the lifetime of the agent (the t
number of percepts it will receive). The lookup table will contain \(\sum_{t=1}^T |P|^t\) entries.</p>
</blockquote>
<p>In our case, we've asked the agent to handle all possible percepts for the rest of time. Sparing the 
proof this results in a lookup table that is infinite, and the capacity to do such a computation is
impossible. What simple changes could be made to our agent such that it can act rationally according
to the weather but not use excessive resources?</p>
<h1><a class="header" href="#simple-reflexes" id="simple-reflexes">Simple Reflexes</a></h1>
<p>Following our question from the last section, hopefully, we have both arrived at the conclusion
that our window agent <em>does not</em> need to store the entire percept sequence to determine its action.
In fact, it is perfectly suited to the same reflex pattern shown in figure 2.8 for the
vacuum cleaner. It can look at a single percept, Sunny or Rainy; and Open or Close respectively.</p>
<blockquote>
<p><strong>function</strong> SIMPLE-REFLEX-AGENT(<em>percept</em>) <strong>returns</strong> an action<br />
 <strong>persistent</strong>: <em>rules</em>, a set of condition-action rules</p>
<p> <em>state</em> ← INTERPRET-INPUT(<em>percept</em>)<br />
 <em>rule</em> ← RULE-MATCH(<em>state</em>,<em>rules</em>)<br />
 <em>action</em> ← <em>rule</em>.ACTION<br />
 <strong>return</strong> <em>action</em></p>
<hr />
<p><strong>Figure 2.8</strong> A simple reflex agent. It acts according to a rule whose condition matches the current state, as defined by the percept.</p>
</blockquote>
<p>In so far as this agent only has to react to a single percept and not the entire sequence, it is more simple. However,
now instead of a simple table lookup, we have two generic functions that are included: <code>INTERPRET-INPUT</code> and <code>RULE-MATCH</code>.</p>
<p>We can envision that the API for such an agent might look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use aima_rust::agents::reflex::{self, SimpleReflexAgent};
</span><span class="boring">use aima_rust::agents::envs::weather::{Window, Weather};
</span>let interpet_input = |percept| percept; // identity function

let rule_match = |percept| match percept {
    Weather::Sunny =&gt; Window::Open,
    Weather::Rainy =&gt; Window::Close
};

let agent = SimpleReflexAgent::new(interpet_input, rule_match);
<span class="boring">}
</span></code></pre></pre>
<p>The actual nuts and bolts to make this work in the same fashion as our prior agent gets a little bit verbose.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct SimpleReflexAgent&lt;Percept, State, Action, InterpretFn, RuleFn&gt;
where
    InterpretFn: FnOnce(Percept) -&gt; State,
    RuleFn: FnOnce(State) -&gt; Action,
{
    interpret_input: InterpretFn,
    rule_match: RuleFn,
    _phantom: PhantomData&lt;(Percept, State, Action)&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we have a <code>struct</code> that can store our two functions generically over any sort of <code>Percept</code>, <code>State</code>, and
<code>Action</code>. Recall that <code>State</code> is derived from the interpret input function. That is a (maybe) lightweight
transformation of the percept to something ready for rule matching. As an example, let's introduce some more
complexity to the environment. Let's say instead of just Sunny and Rainy, it can also be Cloudy, Partly Cloudy,
or even Thunderstorm:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Weather {
    Sunny, Rainy, Cloudy, PartlyCloudy, Thunderstorm
}
<span class="boring">}
</span></code></pre></pre>
<p>Many of these sensor readings inevitably will lead to the same rational rule execution in our agent. We can create
a <code>State</code> that more succinctly represents the outside world in terms of how the agent may respond.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum State{
    Good, Bad
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we can define the <code>INTERPRET-INPUT</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let interpret_input = |percept| match percept {
    Weather::Sunny =&gt; State::Good,
    Weather::PartlyCloudy =&gt; State::Good,
    Weather::Rainy =&gt; State::Bad,
    Weather::Thunderstorm =&gt; State::Bad,

    Weather::Cloudy =&gt; unimplimented!() // ???
};
<span class="boring">}
</span></code></pre></pre>
<p>You should notice that <code>interpret_input(Weather::Cloudy)</code> is undefined. In fact, if you run that,
the entire program will crash! The thing is, we're not quite smart enough to say if this percept signals
a good state or a bad state. Sometimes cloudiness leads to rain and other times it does not. We also haven't said much about
how often our sensors get a reading or how accurate they are. Let's introduce a third enumeration:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum State{
    Good, Bad, Unknown(Weather)
}
<span class="boring">}
</span></code></pre></pre>
<p>We can now complete our function by adding a catch-all at the end for percepts we can't bucket into just
Good or Bad.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let interpret_input = |percept| match percept {
    Weather::Sunny =&gt; State::Good,
    Weather::PartlyCloudy =&gt; State::Good,
    Weather::Rainy =&gt; State::Bad,
    Weather::Thunderstorm =&gt; State::Bad,

    _ =&gt; State::Unknown(_)
};
<span class="boring">}
</span></code></pre></pre>
<p>With our new atmospheric conditions and simplified state interpretation in hand, let's get back to the interesting parts.
Our agent has a singular task of opening and closing the window when appropriate. To do that, we can update the <code>RULE-MATCH</code>
function.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let rule_match = |state| match state {
    State::Good =&gt; Window::Open,
    State::Bad =&gt; Window::Close,
    State::Unknown =&gt; unimplimented!() // ???
};
<span class="boring">}
</span></code></pre></pre>
<p>We are left in a similar scenario as last time. How can we choose an action when we are in an undefined state? We could
take the risk-averse path and always close the window whenever we are uncertain about what rule to apply. However, there
will surely be times when the window should be open and the house is getting awful stuffy! Another option would be to
leave things as they are, and if an undefined state comes along, we simply crash. Neither seems to be the makings
of a very reliable agent. </p>
<p>Instead, what we propose is to allow the agent to return a successful action or an error with the reason
it could not complete its task. This may turn out to be a very useful construct, for example, what if instead of a 
simple closure, we are actually interacting with the <a href="https://www.weather.gov/documentation/services-web-api">National Weather Service's API</a>
over TCP, and in-the-midst of our work, an underground internet cable is cut? Should we crash then? It could be perhaps
helpful to delegate an agent error to some other part of the system or trigger a phone call to the Window Agent customer
support center. </p>
<p>These are all reactions that could be feasibly undertaken in the encapsulation of our agent's <code>rule_match</code> function, perhaps,
with a default behaviour of closing the window until some sensible percept comes along. However, let's use what seems like
better judgement and go with the approach of the agent being <em>fallible</em>. This is an area where Rust starts to shine.
If you haven't yet, go take a look at the <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust book's chapter on error handling</a>.</p>
<p>Note too, we haven't included an <code>impl SimpleReflexAgent</code> that defines the <code>run</code> function like we did in the last section.
Can you derive the implementation and test it with our new functions and sensor readings?</p>
<h1><a class="header" href="#fallibility" id="fallibility">Fallibility</a></h1>
<p>In the last section, we left off with the idea that our reflex agent cannot always respond with an
action. We could put the <a href="chapter_2_table.html">Table Driven Agent</a> in the same situation by relaxing 
the constraints of the table somewhat. Let's say it is 1970 and we are the designers of the
Window Agent. At the time, the table approach seems most reasonable, and given our computational
limits we can only generate a table that will that includes percept sequences up to the year 2000. Our
product comes with a lifetime guarantee, so, as part of that we include a little red blinking light
that comes on if the product needs maintenance. If our agent encounters a percept sequence in Y2K, we can
return an error, and allow the parent system to turn on the red blinking light.</p>
<p>Let's bring back our <code>TableDrivenAgent</code> implementation:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(trait_alias)]
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">trait Lookup = Eq + std::hash::Hash;
</span><span class="boring">
</span><span class="boring">type Table&lt;Percept: Lookup, Action&gt; = HashMap&lt;Vec&lt;Percept&gt;, Action&gt;;
</span><span class="boring">struct TableDrivenAgent&lt;Percept: Lookup, Action&gt;{
</span><span class="boring">    percepts: Vec&lt;Percept&gt;,
</span><span class="boring">    table: Table&lt;Percept, Action&gt;
</span><span class="boring">}
</span><span class="boring">impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
</span><span class="boring">  fn new(table: Table&lt;Percept, Action&gt;) -&gt; Self {
</span><span class="boring">      TableDrivenAgent {
</span><span class="boring">          table, percepts: Vec::new()
</span><span class="boring">      }
</span><span class="boring">  }
</span><span class="boring">}
</span>impl&lt;Percept: Lookup, Action&gt; TableDrivenAgent&lt;Percept, Action&gt; {
    // Run is called for each percept received from the environment
    fn run(&amp;mut self, percept: Percept) -&gt; &amp;Action {
        // Push the percept into our history sequence
        self.percepts.push(percept);
        // Lookup an action for the history sequence and return it
        self.table.get(&amp;self.percepts).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We can update the <code>run</code> signature quite easily to return Rust's <code>std::result::Result</code> type. First, let's
create a couple symbols to represent our agent's result and potential errors.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Error {
    RequestedY2K
}

type Result&lt;A&gt; = std::result::Result&lt;A, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Now, let's update the <code>run</code> implementation:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  fn run(&amp;mut self, percept: Percept) -&gt; Result&lt;&amp;Action&gt; {
      self.percepts.push(percept);
      self.table.get(&amp;self.percepts)
        // if the action is found in the table,
        // return Result::Ok(action)
        .map(Ok)
        // elsewise, return Result::Errr(error)
        .unwrap_or(Err(Error::RequestedY2K))
  }
<span class="boring">}
</span></code></pre></pre>
<p>You might be wondering why we could have so naively written
a crashable program in the first place. One of the principles for using Rust was indeed that it <em>is error 
resilient</em>! If you've read the Rust book chapter on error handling, then you realize that <code>panic!</code> crashing
is in the toolkit of an agent designer. What you might not have known, is that <code>unwrap()</code> functions almost
always have a <code>panic!</code> clause. When we retrieve an item from the <code>Table</code> using <code>get</code>, it returns an <code>Option</code>.
Unwrap on an option that contains <code>None</code> results in a <code>panic!</code>. This is always layed out in the documentation 
for a function with a heading <strong># Panics</strong> as <a href="https://doc.rust-lang.org/beta/std/option/enum.Option.html#method.unwrap">you can see here</a>.</p>
<p>Our table driven agent is now relaxed so that <em>any</em> table can be included and used as a lookup
without allowing the program to crash. A caller of the agent can interpret the result as an action or error
and delegate next steps appropriately. For example,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>agent.run(Weather::Cloudy)
    .map_err(|err| start_red_blinking_light())
<span class="boring">}
</span></code></pre></pre>
<p>Well, it's 1960, so this is still a leap-forward compared to the competition. That reminds us, we haven't introduced
fallibility to the Simple Reflex Agent. Can you pause and do that now?</p>
<h1><a class="header" href="#model-based" id="model-based">Model Based</a></h1>
<blockquote>
<p><strong>function</strong> MODEL-BASED-REFLEX-AGENT(<em>percept</em>) <strong>returns</strong> an action<br />
 <strong>persistent</strong>: <em>state</em>, the agent's current conception of the world state<br />
      <em>model</em>, how the next state depends on current state and action<br />
      <em>rules</em>, a set of condition-action rules<br />
      <em>action</em>, the most recent action, initially none</p>
<p> <em>state</em> ← UPDATE-STATE(<em>state</em>, <em>action</em>, <em>percept</em>, <em>model</em>)<br />
 <em>rule</em> ← RULE-MATCH(<em>state</em>,<em>rules</em>)<br />
 <em>action</em> ← <em>rule</em>.ACTION<br />
 <strong>return</strong> <em>action</em></p>
<hr />
<p><strong>Figure 2.12</strong> A model-based reflex agent. It keeps track of the current state of the world, using an internal model. 
It then chooses an action in the same way as the reflex agent.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
